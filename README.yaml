name: Terraform AWS EC2 Instance
#logo: logo/logo.jpg

license: "APACHE2"

copyrights:
  - name: "Cloud Ops Works LLC"
    url: "https://cloudops.works"
    year: "2024"

github_repo: cloudopsworks/terraform-module-aws-ec2-instances

description: |-
  Opinionated Terraform module for provisioning and managing Amazon EC2 instances at scale.
  It standardizes AMI discovery, instance types, networking, IAM, storage, and backups
  behind a simple, predictable input schema. Optional capabilities include Spot requests,
  automatic key pair and security group creation, dedicated host support, and sensible
  tagging â€” keeping EC2 deployments consistent, auditable, and reproducible across environments.

# Introduction to the project
introduction: |-
  This module provides a straightforward, opinionated way to create and manage EC2 instances
  in AWS. It supports on-demand and Spot instances, AMI discovery, flexible networking,
  IAM integration, storage configuration, optional automatic key pair and security group
  creation, and dedicated host placement.
  
  The module expects an org object to drive consistent naming and tagging across resources.
  Managing instances as code with Terraform (and Terragrunt) enables reviewable changes,
  auditability, and repeatable deployments across environments with minimal boilerplate.

# How to use this project
usage: |-
  To incorporate this module, reference it with Terragrunt and follow the .boilerplate structure in the "develop" branch of this repository.
  
  Basic steps to use the module:
  1. Install Terraform (v1.0 or higher) and Terragrunt.
  2. Create or update your Terragrunt configuration files using the .boilerplate patterns.
  3. Provide inputs: org (required), name or name_prefix, and the instance map (see schema below). Optionally adjust iam/timeouts.
     - By default, iam.create = true and the module creates an IAM role and instance profile.
       To reuse an existing profile instead, set iam.create = false and set iam.instance_profile.
     - For Spot instances, set instance.create_spot = true and optionally configure instance.spot options.
     - Configure the AWS provider (e.g., region) in your stack.
  4. Run terragrunt init to initialize your working directory.
  5. Run terragrunt plan to view resource changes.
  6. Run terragrunt apply to create the resources.
  
  Available Variables:

  name: (string, optional)
    - The name of the EC2 Instance
    - Default: ""

  name_prefix: (string, optional)
    - The name prefix of the EC2 Instance
    - Default: ""

  org: (object, required)
    - Organization and environment context used for consistent naming and tagging
    - Keys:
      - organization_name (string)
      - organization_unit (string)
      - environment_type (string)
      - environment_name (string)

  is_hub: (bool, optional)
    - Whether this stack represents a HUB configuration
    - Default: false

  spoke_def: (string, optional)
    - Spoke identifier used in the computed system name
    - Default: "001"

  extra_tags: (map(string), optional)
    - Additional tags to merge with common tags and apply to resources
    - Default: {}

  instance: (map, optional)
    Complex configuration for EC2 instance. Supports following structure:
    ```yaml
    instance:
      create: true | false     # defaults to true
      create_spot: true | false # defaults to false
      ignore_ami_changes: true | false # defaults to false
      spot:
        price: "0.02"                        # optional max price; omit to use current market
        type: "one-time"                     # "one-time" | "persistent" (default: "one-time")
        wait_for_fulfillment: true | false   # defaults to true
        launch_group: "group-name"           # optional
        block_duration_minutes: 60           # optional
        instance_interruption_behavior: "terminate" | "stop" | "hibernate"
        valid_from: "2025-01-01T00:00:00Z"   # optional
        valid_until: "2025-12-31T23:59:59Z"  # optional
      dedicated_host:           # launch into a dedicated host when enabled (not for spot)
        enabled: true | false   # defaults to false
        instance_family: "c7i"  # optional; else uses instance.type
        host_recovery: true | false
        auto_placement: "on" | "off"
      ami:
        name: "ami-name"        # optional; if provided, ami.id is ignored
        architecture: "x86_64" | "arm64" # defaults to "x86_64"
        id: "ami-id"            # optional; used when ami.name is not provided
        most_recent: true | false # defaults to true
        owners: ["self"]        # defaults to ["self"]
        filters:                # defaults to []
          - name: "filter-name"
            values: ["filter-value"]
      type: "t2.micro"          # defaults to "t2.micro"
      hibernation: true | false
      user_data: "user-data"
      user_data_base64: "user-data-base64"
      user_data_replace_on_change: true | false
      cpu_options:
        core_count: 1
        threads_per_core: 1
        amd_sev_snp: true | false
      availability_zone: "us-east-1a"
      key_pair:
        create: true | false    # defaults to false (creates and tags a new key)
        name: "existing-key-name" # if create=false, use this existing key
      monitoring: true | false
      get_password_data: true | false
      vpc:
        security_group_ids: ["sg-12345678"]
        associate_public_ip_address: true | false
        subnet_id: "subnet-id"
        private_ip: "private-ip"
        secondary_private_ips: ["secondary-private-ip"]
        ipv6_address_count: 1
        ipv6_addresses: ["ipv6-address"]
      security_group:
        create: true | false    # defaults to false; when true, module creates a SG in the subnet's VPC
        rules:                  # optional map of rules applied when create=true
          ssh:
            type: "ingress"
            from_port: 22
            to_port: 22
            protocol: "tcp"
            cidr_blocks: ["0.0.0.0/0"]
      network_interface:
        create: true | false    # defaults to false
        subnet_id: "subnet-id"  # required when create=true
        private_ips: ["private-ip"]
        delete_on_termination: true | false
        network_interface_id: "eni-id"
      # For Spot instances, use a list of network_interface blocks:
      # network_interface:
      #   - device_index: 0
      #     network_interface_id: "eni-id"
      #     delete_on_termination: true | false # defaults to true
      root_block_device:
        - volume_size: 8
          volume_type: "gp3"
          iops: 3000
          throughput: 125
          encrypted: true | false
          kms_key_id: "kms-key-id"
          delete_on_termination: true | false
          tags: { "Name": "root-volume" }
      ebs:
        ebs_optimized: true | false
        block_device:
          - device_name: "/dev/xvdb"
            volume_size: 8
            volume_type: "gp3"
            iops: 3000
            throughput: 125
            encrypted: true
            kms_key_id: "kms-key-id"
            snapshot_id: "snap-1234"
            delete_on_termination: true
            tags: { "Name": "data-volume" }
      ephemeral_block_device:
        - device_name: "/dev/sdh"
          virtual_name: "ephemeral0"
          no_device: true
      metadata_options:
        http_endpoint: "enabled" | "disabled"    # defaults to "enabled"
        http_tokens: "required" | "optional"     # defaults to "optional"
        http_put_response_hop_limit: 1
        instance_metadata_tags: "enabled" | "disabled" # defaults to "enabled"
      private_dns_name_options:
        hostname_type: "ip-name" | "resource-name"
        enable_resource_name_dns_a_record: true | false
        enable_resource_name_dns_aaaa_record: true | false
      maintenance_options:
        auto_recovery: "default" | "disabled"
      enclave_options:
        enabled: true | false
      cpu_credits: "standard" | "unlimited"      # for T-family instances only
      capacity_reservation_specification:
        capacity_reservation_preference: "open" | "none"
        capacity_reservation_target:
          capacity_reservation_id: "cr-0123456789abcdef0"
          capacity_reservation_resource_group_arn: "arn:aws:resource-groups:..."
      source_dest_check: true | false
      disable_api_termination: true | false
      disable_api_stop: true | false
      instance_initiated_shutdown_behavior: "stop" | "terminate"
      placement_group: "placement-group"
      tenancy: "default" | "dedicated"
      host_id: "h-0123456789abcdef0"             # optional; used when attaching to an existing dedicated host
      backup:
        enabled: true | false                     # defaults to false
        only_tag: true | false                    # defaults to true
        schedule: hourly | daily | weekly | monthly # defaults to daily; used for the 'aws-backup-schedule' tag
      extra_tags: { "env": "dev" }                # additional tags for the instance
      volume_extra_tags: { "tier": "gold" }       # additional tags for EBS volumes
    ```

  timeouts: (map, optional)
    - The timeouts configuration for the EC2 Instance
    - Default: {}

  iam: (map, optional)
    IAM configuration for the EC2 instance profile:
    ```yaml
    iam:
      create: true | false                 # defaults to true; when true module creates role + instance profile
      path: "/service-role/"              # optional IAM path
      role_description: "IAM Instance Role <name>" # optional description
      permissions_boundary: "arn:aws:iam::123456789012:policy/BoundaryPolicy" # optional
      extra_tags: { "team": "platform" } # optional tags for IAM resources
      role_policies:                       # optional map (name => policy ARN) to attach to the role
        ssm: "arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore"
      instance_profile: "existing-profile" # used only when create=false to use an existing instance profile
    ```

  Example of a Terragrunt configuration referencing this module (terragrunt.hcl):
  ```hcl
  terraform {
    source = "git::https://github.com/cloudopsworks/terraform-module-aws-ec2-instances.git//?ref=develop"
  }

  inputs = {
    org = {
      organization_name = "acme"
      organization_unit = "platform"
      environment_type  = "nonprod"
      environment_name  = "dev"
    }

    name = "my-instance"

    instance = {
      create = true
      type   = "t3.micro"

      ami = {
        name   = "my-custom-ami"
        owners = ["self"]
      }

      key_pair = {
        create = false
        name   = "my-existing-key"
      }

      vpc = {
        subnet_id          = "subnet-123456"
        security_group_ids = ["sg-123456"]
      }

      # Optionally let module create and manage a security group with rules:
      # security_group = {
      #   create = true
      #   rules = {
      #     ssh = {
      #       type        = "ingress"
      #       from_port   = 22
      #       to_port     = 22
      #       protocol    = "tcp"
      #       cidr_blocks = ["0.0.0.0/0"]
      #     }
      #   }
      # }
    }

    # By default, the module creates an IAM role and instance profile (iam.create = true).
    # To use an existing instance profile instead:
    iam = {
      create           = false
      instance_profile = "my-existing-profile"
    }
  }
  ```

# Example usage
examples: |-
  Here are sample use cases you can adapt in the .boilerplate files on the "develop" branch:
  
  1. Single Development Instance
     - Minimal inputs to spin up a small on-demand instance for dev/testing.
  
  2. Spot Instance for Cost Optimization
     - Set instance.create_spot = true to request spot capacity with the same configuration.
  
  3. Dedicated Host Placement
     - Set instance.dedicated_host.enabled = true to launch on a dedicated host (supported for the type). Optionally set instance.dedicated_host.instance_family or use host_id to attach to an existing host.
  
  4. Private Subnet Deployment
     - Provide instance.vpc.subnet_id and security_group_ids; omit public IP or set associate_public_ip_address = false.
  
  5. Custom Storage and Metadata
     - Use instance.root_block_device or instance.ebs.block_device for volumes, and instance.metadata_options to enforce IMDSv2.
  
  For more Terragrunt-based examples and structural hints, see the .boilerplate directory in the "develop" branch.

# How to get started quickly
quickstart: |-
  1. Clone or fork the repository to review the .boilerplate templates under the "develop" branch.
  2. Adapt the relevant Terragrunt configuration files for your own environment by referencing this module.
  3. Initialize your workspace using terragrunt init.
  4. Review proposed infrastructure changes by running terragrunt plan.
  5. Finally, configure and deploy your EC2 instances with terragrunt apply.

include:
  - "docs/targets.md"
  - "docs/terraform.md"

contributors:
  - name: "Cristian Beraha"
    github: "berahac"